import { compile, type JSONSchema } from 'json-schema-to-typescript';
import type { SpaceComponent } from '../../../commands/components/constants';
import { handleFileSystemError, toCamelCase, toPascalCase } from '../../../utils';
import type { GenerateTypesOptions } from './constants';
import type { StoryblokPropertyType } from '../../../types/storyblok';
import { storyblokSchemas } from '../../../utils/storyblok-schemas';
import { join, resolve } from 'node:path';
import { resolvePath, saveToFile } from '../../../utils/filesystem';
import { readFileSync } from 'node:fs';
import type { ComponentPropertySchema } from '../../../types/schemas';

export interface ComponentGroupsAndNamesObject {
  componentGroups: Map<string, Set<string>>;
  componentNames: Set<string>;
}

// Constants
const DEFAULT_TYPEDEFS_HEADER = [
  '// This file was generated by the storyblok CLI.',
  '// DO NOT MODIFY THIS FILE BY HAND.',
];

const getPropertyTypeAnnotation = (property: ComponentPropertySchema) => {
  // If a property type is one of the ones provided by Storyblok, return that type
  // Casting as string[] to avoid TS error on using Array.includes on different narrowed types
  if (Array.from(storyblokSchemas.keys()).includes(property.type as StoryblokPropertyType)) {
    return { type: property.type };
  }

  // Initialize property type as any (fallback type)
  // const type: string | string[] = 'any';

  const options = property.options && property.options.length > 0 ? property.options.map((item: { value: string }) => item.value) : [];

  // Add empty option to options array
  if (options.length > 0 && property.exclude_empty_option !== true) {
    options.unshift('');
  }

  switch (property.type) {
    case 'bloks':
      return { type: 'array' };
    case 'boolean':
      return { type: 'boolean' };
    case 'datetime':
    case 'image':
    case 'markdown':
    case 'number':
    case 'text':
    case 'textarea':
      return { type: 'string' };
    default:
      return { type: 'any' };
  }
};

export const getComponentType = (
  componentName: string,
  options: GenerateTypesOptions,
): string => {
  const prefix = options.typeNamesPrefix ?? '';
  const suffix = options.typeNamesSuffix ?? '';

  // Sanitize the component name to handle special characters and emojis
  const sanitizedName = componentName
    // Replace any character that's not a letter or number with an underscore
    .replace(/[^a-z0-9]/gi, '_')
    // Replace multiple consecutive underscores with a single underscore
    .replace(/_+/g, '_')
    // Trim underscores from the beginning and end
    .replace(/^_+|_+$/g, '');

  // Convert to PascalCase
  const componentType = toPascalCase(toCamelCase(`${prefix}_${sanitizedName}_${suffix}`));

  // If the component type starts with a number, prefix it with an underscore
  const isFirstCharacterNumber = !Number.isNaN(Number.parseInt(componentType.charAt(0)));
  return isFirstCharacterNumber ? `_${componentType}` : componentType;
};

const getComponentPropertiesTypeAnnotations = async (
  component: SpaceComponent,
  options: GenerateTypesOptions,
  componentsMaps: ComponentGroupsAndNamesObject,
): Promise<JSONSchema['properties']> => {
  return Object.entries<Record<string, any>>(component.schema).reduce(async (accPromise, [key, value]) => {
    const acc = await accPromise;

    // Skip tabbed properties
    if (key.startsWith('tab-')) {
      return acc;
    }

    const propertyType = value.type;
    const propertyTypeAnnotation: JSONSchema = {
      [key]: getPropertyTypeAnnotation(value as ComponentPropertySchema),
    };

    if (propertyType === 'custom') {
      return {
        ...acc,
        // TODO: Add custom type annotation
      };
    }

    if (Array.from(storyblokSchemas.keys()).includes(propertyType as StoryblokPropertyType)) {
      const componentType = getComponentType(propertyType, options);
      propertyTypeAnnotation[key].tsType = `Storyblok${componentType}`;
    }

    if (propertyType === 'multilink') {
      const excludedLinktypes: string[] = [
        ...(!value.email_link_type ? ['{ linktype?: "email" }'] : []),
        ...(!value.asset_link_type ? ['{ linktype?: "asset" }'] : []),
      ];
      const componentType = getComponentType(propertyType, options);
      propertyTypeAnnotation[key].tsType
        = excludedLinktypes.length > 0 ? `Exclude<Storyblok${componentType}, ${excludedLinktypes.join(' | ')}>` : componentType;
    }

    if (propertyType === 'bloks') {
      if (value.restrict_components) {
        // Components restricted by groups
        if (value.restrict_type === 'groups') {
          if (
            Array.isArray(value.component_group_whitelist)
            && value.component_group_whitelist.length > 0
          ) {
            const componentsInGroupWhitelist = value.component_group_whitelist.reduce(
              (components: string[], groupUUID: string) => {
                const componentsInGroup = componentsMaps.componentGroups.get(groupUUID);

                return componentsInGroup
                  ? [
                      ...components,
                      ...Array.from(componentsInGroup).map(componentName => getComponentType(componentName, options)),
                    ]
                  : components;
              },
              [],
            );

            propertyTypeAnnotation[key].tsType
              = componentsInGroupWhitelist.length > 0 ? `(${componentsInGroupWhitelist.join(' | ')})[]` : `never[]`;
          }
        }
        else {
          // Components restricted by 1-by-1 list
          if (Array.isArray(value.component_whitelist) && value.component_whitelist.length > 0) {
            propertyTypeAnnotation[key].tsType = `(${value.component_whitelist
              .map((name: string) => getComponentType(name, options))
              .join(' | ')})[]`;
          }
        }
      }
      else {
        // All components can be slotted in this property (AKA no restrictions)
        propertyTypeAnnotation[key].tsType = `(${Array.from(componentsMaps.componentNames)
          .map(componentName => getComponentType(componentName, options))
          .join(' | ')})[]`;
      }
    }

    return { ...acc, ...propertyTypeAnnotation };
  }, Promise.resolve({} as JSONSchema));
};
export const generateComponentGroupsAndComponentNames = (
  components: SpaceComponent[],
): ComponentGroupsAndNamesObject => {
  return components.reduce<ComponentGroupsAndNamesObject>(
    (acc, currentComponent) => {
      if (currentComponent.component_group_uuid) {
        acc.componentGroups.set(
          currentComponent.component_group_uuid,
          acc.componentGroups.has(currentComponent.component_group_uuid)
            ? acc.componentGroups.get(currentComponent.component_group_uuid)!.add(currentComponent.name)
            : new Set([currentComponent.name]),
        );
      }
      acc.componentNames.add(currentComponent.name);
      return acc;
    },
    { componentGroups: new Map(), componentNames: new Set() },
  );
};

export const generateTypes = async (
  components: SpaceComponent[],
  options: GenerateTypesOptions = {
    strict: false,
  },
) => {
  const componentsMaps = generateComponentGroupsAndComponentNames(components);
  /* const { componentGroups, componentNames } = generateComponentGroupsAndComponentNames(components);
  const typedefs = [...DEFAULT_TYPEDEFS_HEADER]; */
  const typeDefs = [...DEFAULT_TYPEDEFS_HEADER];
  const storyblokPropertyTypes = new Set<string>();

  const schemas = await Promise.all(components.map(async (component) => {
    // Get the component type name with proper handling of numbers at the start
    const type = getComponentType(component.name, options);
    const componentPropertiesTypeAnnotations = await getComponentPropertiesTypeAnnotations(component, options, componentsMaps);
    const requiredFields = Object.entries<Record<string, any>>(component.schema).reduce(
      (acc, [key, value]) => {
        if (value.required) {
          return [...acc, key];
        }
        return acc;
      },
      ['component', '_uid'],
    );

    // Check if any property has a type that's in storyblokSchemas.keys()
    if (componentPropertiesTypeAnnotations) {
      Object.entries(componentPropertiesTypeAnnotations).forEach(([_, property]) => {
        if (property.type && Array.from(storyblokSchemas.keys()).includes(property.type as StoryblokPropertyType)) {
          storyblokPropertyTypes.add(property.type as StoryblokPropertyType);
        }
      });
    }

    const componentSchema: JSONSchema = {
      $id: `#/${component.name}`,
      title: type, // This is the key - we're using the properly formatted type name
      type: 'object',
      required: requiredFields,
      properties: {
        ...componentPropertiesTypeAnnotations,
        component: {
          type: 'string',
          enum: [component.name],
        },
        _uid: {
          type: 'string',
        },
      },
    };

    return componentSchema;
  }));

  const result = await Promise.all(schemas.map(async (schema) => {
    // Use the title as the interface name
    return await compile(schema, schema.title || schema.$id.replace('#/', ''), {
      additionalProperties: !options.strict,
      bannerComment: '',
    });
  }));

  // Add imports for Storyblok types if needed
  const imports: string[] = [];
  if (storyblokPropertyTypes.size > 0) {
    const typeImports = Array.from(storyblokPropertyTypes).map((type) => {
      const pascalType = toPascalCase(type);
      return `Storyblok${pascalType}`;
    });

    imports.push(`import type { ${typeImports.join(', ')} } from '../storyblok.d.ts';`);
  }

  const finalTypeDef = [...typeDefs, ...imports, ...result];

  return [
    ...finalTypeDef,
  ].join('\n');
};

export const saveTypesToFile = async (space: string, typedefString: string, options: SaveTypesOptions) => {
  const { filename = 'storyblok-components', path } = options;
  // Ensure we always include the components/space folder structure regardless of custom path
  const resolvedPath = path
    ? resolve(process.cwd(), path, 'types', space)
    : resolvePath(path, `types/${space}`);

  try {
    await saveToFile(join(resolvedPath, `${filename}.d.ts`), typedefString);
  }
  catch (error) {
    handleFileSystemError('write', error as Error);
  }
};

// Add SaveTypesOptions interface
export interface SaveTypesOptions {
  filename?: string;
  path?: string;
}

/**
 * Generates a d.ts file with the Storyblok type definitions
 * @param options - Options for generating the types
 * @returns Promise that resolves when the file is saved
 */
export const generateStoryblokTypes = async (options: SaveTypesOptions = {}) => {
  const { filename = 'storyblok', path } = options;

  try {
    // Get the path to the storyblok.ts file
    const storyblokTypesPath = resolve(process.cwd(), 'src', 'types', 'storyblok.ts');

    // Read the content of the storyblok.ts file
    const storyblokTypesContent = readFileSync(storyblokTypesPath, 'utf-8');

    // Extract the type definitions using a more robust approach
    const lines = storyblokTypesContent.split('\n');
    const typeDefinitions: string[] = [];
    let isCollecting = false;
    let bracketCount = 0;
    let currentType = '';

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];

      // Check if this line starts a type definition
      if (line.includes('export type StoryblokPropertyType')
        || line.includes('export interface Storyblok')) {
        // If we were already collecting a type, add it to our results
        if (isCollecting) {
          typeDefinitions.push('');
        }

        isCollecting = true;
        typeDefinitions.push(line);
        currentType = line.includes('type') ? 'type' : 'interface';

        // Count opening and closing braces to handle nested structures
        bracketCount += (line.match(/\{/g) || []).length;
        bracketCount -= (line.match(/\}/g) || []).length;

        // For types, we don't need to collect more lines
        if (currentType === 'type') {
          isCollecting = false;
          continue;
        }

        // For interfaces, continue collecting lines until we've matched all braces
        let j = i + 1;
        while (j < lines.length && bracketCount > 0) {
          const nextLine = lines[j];
          bracketCount += (nextLine.match(/\{/g) || []).length;
          bracketCount -= (nextLine.match(/\}/g) || []).length;
          typeDefinitions.push(nextLine);
          j++;
        }

        // Skip the lines we've already processed
        i = j - 1;
        isCollecting = false;
      }
    }

    // Define the content of the d.ts file
    const typeDefs = [
      '// This file was generated by the storyblok CLI.',
      '// DO NOT MODIFY THIS FILE BY HAND.',
      '',
      ...typeDefinitions,
    ].join('\n');

    // Determine the path to save the file
    const resolvedPath = path
      ? resolve(process.cwd(), path, 'types')
      : resolvePath(path, 'types');

    await saveToFile(join(resolvedPath, `${filename}.d.ts`), typeDefs);
    return true;
  }
  catch (error) {
    handleFileSystemError('read', error as Error);
    return false;
  }
};
