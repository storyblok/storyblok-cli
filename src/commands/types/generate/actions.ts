import { compile, type JSONSchema } from 'json-schema-to-typescript';
import type { SpaceComponent } from '../../../commands/components/constants';
import { handleFileSystemError, toCamelCase, toPascalCase } from '../../../utils';
import type { GenerateTypesOptions } from './constants';
import type { ComponentPropertySchema, StoryblokPropertyType } from '../../../types/storyblok';
import { storyblokSchemas } from '../../../utils/storyblok-schemas';
import { join, resolve } from 'node:path';
import { resolvePath, saveToFile } from '../../../utils/filesystem';

export interface ComponentGroupsAndNamesObject {
  componentGroups: Map<string, Set<string>>;
  componentNames: Set<string>;
}

// Constants
const STORY_TYPE = 'ISbStoryData';
const DEFAULT_TYPEDEFS_HEADER = [
  '// This file was generated by the storyblok CLI.',
  '// DO NOT MODIFY THIS FILE BY HAND.',
  `import type { ${STORY_TYPE} } from "storyblok";`,
];

const getPropertyTypeAnnotation = (property: ComponentPropertySchema) => {
  // If a property type is one of the ones provided by Storyblok, return that type
  // Casting as string[] to avoid TS error on using Array.includes on different narrowed types
  if (Array.from(storyblokSchemas.keys()).includes(property.type as StoryblokPropertyType)) {
    return { type: property.type };
  }

  // Initialize property type as any (fallback type)
  // const type: string | string[] = 'any';

  const options = property.options && property.options.length > 0 ? property.options.map(item => item.value) : [];

  // Add empty option to options array
  if (options.length > 0 && property.exclude_empty_option !== true) {
    options.unshift('');
  }

  switch (property.type) {
    case 'bloks':
      return { type: 'array' };
    case 'boolean':
      return { type: 'boolean' };
    case 'datetime':
    case 'image':
    case 'markdown':
    case 'number':
    case 'text':
    case 'textarea':
      return { type: 'string' };
    default:
      return { type: 'any' };
  }
};
const getComponentType = (
  componentName: string,
  options: GenerateTypesOptions,
): string => {
  const prefix = options.typeNamesPrefix ?? '';
  const suffix = options.typeNamesSuffix ?? '';
  const componentType = toPascalCase(toCamelCase(`${prefix}_${componentName}_${suffix}`));
  const isFirstCharacterNumber = !Number.isNaN(Number.parseInt(componentType.charAt(0)));
  return isFirstCharacterNumber ? `_${componentType}` : componentType;
};

const getComponentPropertiesTypeAnnotations = async (
  component: SpaceComponent,
  _options: GenerateTypesOptions,
) => {
  // const typeAnnotations: JSONSchema['properties'] = {};

  const componentPropertiesTypeAnnotations = await Promise.all(
    Object.entries<Record<string, any>>(component.schema).map(async ([key, value]) => {
      if (key.startsWith('tab-')) {
        return;
      }

      const typeAnnotation: JSONSchema = {
        [key]: getPropertyTypeAnnotation(value),
      };

      return { [key]: typeAnnotation };
    }),
  );

  return componentPropertiesTypeAnnotations;
};

export const generateComponentGroupsAndComponentNames = (
  components: SpaceComponent[],
): ComponentGroupsAndNamesObject => {
  return components.reduce<ComponentGroupsAndNamesObject>(
    (acc, currentComponent) => {
      if (currentComponent.component_group_uuid) {
        acc.componentGroups.set(
          currentComponent.component_group_uuid,
          acc.componentGroups.has(currentComponent.component_group_uuid)
            ? acc.componentGroups.get(currentComponent.component_group_uuid)!.add(currentComponent.name)
            : new Set([currentComponent.name]),
        );
      }
      acc.componentNames.add(currentComponent.name);
      return acc;
    },
    { componentGroups: new Map(), componentNames: new Set() },
  );
};

export const generateTypes = async (
  components: SpaceComponent[],
  options: GenerateTypesOptions,
) => {
  /* const { componentGroups, componentNames } = generateComponentGroupsAndComponentNames(components);
  const typedefs = [...DEFAULT_TYPEDEFS_HEADER]; */

  const schemas = await Promise.all(components.map(async (component) => {
    const type = getComponentType(component.name, options);
    const componentPropertiesTypeAnnotations = await getComponentPropertiesTypeAnnotations(component, options);
    const requiredFields = Object.entries<Record<string, any>>(component.schema).reduce(
      (acc, [key, value]) => {
        if (value.required) {
          return [...acc, key];
        }
        return acc;
      },
      ['component', '_uid'],
    );

    const componentSchema: JSONSchema = {
      $id: `#/${component.name}`,
      title: type,
      type: 'object',
      required: requiredFields,
      properties: {
        ...componentPropertiesTypeAnnotations,
        component: {
          type: 'string',
          enum: [component.name],
        },
        _uid: {
          type: 'string',
        },
      },
    };

    return componentSchema;
  }));

  const typedefString = await Promise.all(schemas.map(async (schema) => {
    return await compile(schema, schema.$id.replace('#/', ''), {
      additionalProperties: false,
      bannerComment: '',
    });
  }));

  return [
    ...DEFAULT_TYPEDEFS_HEADER,
    ...typedefString,
  ].join('\n');
};

export const saveTypesToFile = async (space: string, typedefString: string, options: SaveTypesOptions) => {
  const { filename = 'storyblok', path } = options;
  // Ensure we always include the components/space folder structure regardless of custom path
  const resolvedPath = path
    ? resolve(process.cwd(), path, 'types', space)
    : resolvePath(path, `types/${space}`);

  try {
    await saveToFile(join(resolvedPath, `${filename}.d.ts`), typedefString);
  }
  catch (error) {
    handleFileSystemError('write', error as Error);
  }
};
