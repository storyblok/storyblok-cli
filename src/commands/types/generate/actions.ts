import { compile, type JSONSchema } from 'json-schema-to-typescript';
import type { SpaceComponent } from '../../../commands/components/constants';
import { handleFileSystemError, toCamelCase, toPascalCase } from '../../../utils';
import type { GenerateTypesOptions } from './constants';
import type { ComponentPropertySchema, StoryblokPropertyType } from '../../../types/storyblok';
import { storyblokSchemas } from '../../../utils/storyblok-schemas';
import { join, resolve } from 'node:path';
import { resolvePath, saveToFile } from '../../../utils/filesystem';

export interface ComponentGroupsAndNamesObject {
  componentGroups: Map<string, Set<string>>;
  componentNames: Set<string>;
}

// Constants
const DEFAULT_TYPEDEFS_HEADER = [
  '// This file was generated by the storyblok CLI.',
  '// DO NOT MODIFY THIS FILE BY HAND.',
];

const getPropertyTypeAnnotation = (property: ComponentPropertySchema) => {
  // If a property type is one of the ones provided by Storyblok, return that type
  // Casting as string[] to avoid TS error on using Array.includes on different narrowed types
  if (Array.from(storyblokSchemas.keys()).includes(property.type as StoryblokPropertyType)) {
    return { type: property.type };
  }

  // Initialize property type as any (fallback type)
  // const type: string | string[] = 'any';

  const options = property.options && property.options.length > 0 ? property.options.map(item => item.value) : [];

  // Add empty option to options array
  if (options.length > 0 && property.exclude_empty_option !== true) {
    options.unshift('');
  }

  switch (property.type) {
    case 'bloks':
      return { type: 'array' };
    case 'boolean':
      return { type: 'boolean' };
    case 'datetime':
    case 'image':
    case 'markdown':
    case 'number':
    case 'text':
    case 'textarea':
      return { type: 'string' };
    default:
      return { type: 'any' };
  }
};
const getComponentType = (
  componentName: string,
  options: GenerateTypesOptions,
): string => {
  const prefix = options.typeNamesPrefix ?? '';
  const suffix = options.typeNamesSuffix ?? '';
  const componentType = toPascalCase(toCamelCase(`${prefix}_${componentName}_${suffix}`));
  const isFirstCharacterNumber = !Number.isNaN(Number.parseInt(componentType.charAt(0)));
  return isFirstCharacterNumber ? `_${componentType}` : componentType;
};

const getComponentPropertiesTypeAnnotations = async (
  component: SpaceComponent,
  options: GenerateTypesOptions,
): Promise<JSONSchema['properties']> => {
  return Object.entries<Record<string, any>>(component.schema).reduce(async (accPromise, [key, value]) => {
    const acc = await accPromise;

    // Skip tabbed properties
    if (key.startsWith('tab-')) {
      return acc;
    }

    const propertyType = value.type;
    const propertyTypeAnnotation: JSONSchema = {
      [key]: getPropertyTypeAnnotation(value as ComponentPropertySchema),
    };

    if (propertyType === 'custom') {
      return {
        ...acc,
        // TODO: Add custom type annotation
      };
    }

    if (Array.from(storyblokSchemas.keys()).includes(propertyType as StoryblokPropertyType)) {
      const componentType = getComponentType(propertyType, options);
      propertyTypeAnnotation[key].tsType = `Storyblok${componentType}`;

      /* const typedefForStoryblokPropertyType = storyblokSchemas.get(propertyType as StoryblokPropertyType);
      if (typedefForStoryblokPropertyType) {
        typeDef.push(
          await compile(typedefForStoryblokPropertyType, typedefForStoryblokPropertyType.$id.replace('#/', ''), {
            additionalProperties: !options.strict,
            bannerComment: '',
          }),
        );
      } */
    }

    return { ...acc, ...propertyTypeAnnotation };
  }, Promise.resolve({} as JSONSchema));
};
export const generateComponentGroupsAndComponentNames = (
  components: SpaceComponent[],
): ComponentGroupsAndNamesObject => {
  return components.reduce<ComponentGroupsAndNamesObject>(
    (acc, currentComponent) => {
      if (currentComponent.component_group_uuid) {
        acc.componentGroups.set(
          currentComponent.component_group_uuid,
          acc.componentGroups.has(currentComponent.component_group_uuid)
            ? acc.componentGroups.get(currentComponent.component_group_uuid)!.add(currentComponent.name)
            : new Set([currentComponent.name]),
        );
      }
      acc.componentNames.add(currentComponent.name);
      return acc;
    },
    { componentGroups: new Map(), componentNames: new Set() },
  );
};

export const generateTypes = async (
  components: SpaceComponent[],
  options: GenerateTypesOptions = {
    strict: false,
  },
) => {
  /* const { componentGroups, componentNames } = generateComponentGroupsAndComponentNames(components);
  const typedefs = [...DEFAULT_TYPEDEFS_HEADER]; */
  const typeDefs = [...DEFAULT_TYPEDEFS_HEADER];
  const storyblokPropertyTypes = new Set<string>();

  const schemas = await Promise.all(components.map(async (component) => {
    const type = getComponentType(component.name, options);
    const componentPropertiesTypeAnnotations = await getComponentPropertiesTypeAnnotations(component, options);
    const requiredFields = Object.entries<Record<string, any>>(component.schema).reduce(
      (acc, [key, value]) => {
        if (value.required) {
          return [...acc, key];
        }
        return acc;
      },
      ['component', '_uid'],
    );

    // Check if any property has a type that's in storyblokSchemas.keys()
    if (componentPropertiesTypeAnnotations) {
      Object.entries(componentPropertiesTypeAnnotations).forEach(([_, property]) => {
        if (property.type && Array.from(storyblokSchemas.keys()).includes(property.type as StoryblokPropertyType)) {
          storyblokPropertyTypes.add(property.type as StoryblokPropertyType);
        }
      });
    }

    const componentSchema: JSONSchema = {
      $id: `#/${component.name}`,
      title: type,
      type: 'object',
      required: requiredFields,
      properties: {
        ...componentPropertiesTypeAnnotations,
        component: {
          type: 'string',
          enum: [component.name],
        },
        _uid: {
          type: 'string',
        },
      },
    };

    return componentSchema;
  }));

  const result = await Promise.all(schemas.map(async (schema) => {
    return await compile(schema, schema.$id.replace('#/', ''), {
      additionalProperties: !options.strict,
      bannerComment: '',
    });
  }));

  // Add imports for Storyblok types if needed
  const imports: string[] = [];
  if (storyblokPropertyTypes.size > 0) {
    const typeImports = Array.from(storyblokPropertyTypes).map((type) => {
      const pascalType = toPascalCase(type);
      return `Storyblok${pascalType}`;
    });

    imports.push(`import type { ${typeImports.join(', ')} } from '../storyblok.d.ts';`);
  }

  const finalTypeDef = [...typeDefs, ...imports, ...result];

  return [
    ...finalTypeDef,
  ].join('\n');
};

export const saveTypesToFile = async (space: string, typedefString: string, options: SaveTypesOptions) => {
  const { filename = 'storyblok-components', path } = options;
  // Ensure we always include the components/space folder structure regardless of custom path
  const resolvedPath = path
    ? resolve(process.cwd(), path, 'types', space)
    : resolvePath(path, `types/${space}`);

  try {
    await saveToFile(join(resolvedPath, `${filename}.d.ts`), typedefString);
  }
  catch (error) {
    handleFileSystemError('write', error as Error);
  }
};

// Add SaveTypesOptions interface
export interface SaveTypesOptions {
  filename?: string;
  path?: string;
}

/**
 * Generates a d.ts file with the Storyblok type definitions
 * @param options - Options for generating the types
 * @returns Promise that resolves when the file is saved
 */
export const generateStoryblokTypes = async (options: SaveTypesOptions = {}) => {
  const { filename = 'storyblok', path } = options;

  // Define the content of the d.ts file
  const typeDefs = [
    '// This file was generated by the storyblok CLI.',
    '// DO NOT MODIFY THIS FILE BY HAND.',
    '',
    'export type StoryblokPropertyType = \'asset\' | \'multiasset\' | \'multilink\' | \'table\' | \'richtext\';',
    '',
    'export interface StoryblokAsset {',
    '  alt: string | null;',
    '  copyright: string | null;',
    '  fieldtype: \'asset\';',
    '  id: number;',
    '  filename: string | null;',
    '  name: string;',
    '  title: string | null;',
    '  focus: string | null;',
    '  meta_data: Record<string, any>;',
    '  source: string | null;',
    '  is_external_url: boolean;',
    '  is_private: boolean;',
    '  src: string;',
    '  updated_at: string;',
    '  // Cloudinary integration keys',
    '  width: number | null;',
    '  height: number | null;',
    '  aspect_ratio: number | null;',
    '  public_id: string | null;',
    '  content_type: string;',
    '}',
    '',
    'export interface StoryblokMultiasset extends Array<StoryblokAsset> {}',
    '',
    'export interface StoryblokMultilink {',
    '  fieldtype: \'multilink\';',
    '  id: string;',
    '  url: string;',
    '  cached_url: string;',
    '  target?: \'_blank\' | \'_self\';',
    '  anchor?: string;',
    '  rel?: string;',
    '  title?: string;',
    '  prep?: string;',
    '  linktype: \'story\' | \'url\' | \'email\' | \'asset\';',
    '  story?: {',
    '    name: string;',
    '    created_at: string;',
    '    published_at: string;',
    '    id: number;',
    '    uuid: string;',
    '    content: Record<string, any>;',
    '    slug: string;',
    '    full_slug: string;',
    '    sort_by_date?: string;',
    '    position?: number;',
    '    tag_list?: string[];',
    '    is_startpage?: boolean;',
    '    parent_id?: number | null;',
    '    meta_data?: Record<string, any> | null;',
    '    group_id?: string;',
    '    first_published_at?: string;',
    '    release_id?: number | null;',
    '    lang?: string;',
    '    path?: string | null;',
    '    alternates?: any[];',
    '    default_full_slug?: string | null;',
    '    translated_slugs?: any[] | null;',
    '  };',
    '  email?: string;',
    '}',
    '',
    'export interface StoryblokTable {',
    '  thead: Array<{',
    '    _uid: string;',
    '    value: string;',
    '    component: number;',
    '  }>;',
    '  tbody: Array<{',
    '    _uid: string;',
    '    component: number;',
    '    body: Array<{',
    '      _uid: string;',
    '      value: string;',
    '      component: number;',
    '    }>;',
    '  }>;',
    '}',
    '',
    'export interface StoryblokRichtext {',
    '  type: string;',
    '  content?: StoryblokRichtext[];',
    '  marks?: StoryblokRichtext[];',
    '  attrs?: Record<string, any>;',
    '  text?: string;',
    '}',
  ].join('\n');

  // Determine the path to save the file
  const resolvedPath = path
    ? resolve(process.cwd(), path, 'types')
    : resolvePath(path, 'types');

  try {
    await saveToFile(join(resolvedPath, `${filename}.d.ts`), typeDefs);
    return true;
  }
  catch (error) {
    handleFileSystemError('write', error as Error);
    return false;
  }
};
