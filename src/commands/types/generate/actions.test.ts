import { generateStoryblokTypes, generateTypes, getComponentType } from './actions';
import type { SpaceComponent, SpaceData } from '../../../commands/components/constants';
import type { GenerateTypesOptions } from './constants';
import { join, resolve } from 'node:path';
import { vol } from 'memfs';
import { readFileSync } from 'node:fs';

// Import the mocked functions
import { saveToFile } from '../../../utils/filesystem';

// Mock the filesystem module
vi.mock('../../../utils/filesystem', () => ({
  saveToFile: vi.fn().mockResolvedValue(undefined),
  resolvePath: vi.fn().mockReturnValue('/mocked/resolved/path'),
}));

// Mock the fs module
vi.mock('node:fs', () => ({
  readFileSync: vi.fn().mockReturnValue(''),
}));

vi.mock('node:fs/promises');
vi.mock('node:path', () => ({
  resolve: vi.fn().mockReturnValue('/mocked/path'),
  join: vi.fn().mockReturnValue('/mocked/joined/path'),
}));

// Create a mock for the custom fields parser
const mockCustomFieldsParser = vi.fn().mockImplementation((key, field) => {
  if (field.field_type === 'native-color-picker') {
    return {
      [key]: {
        properties: {
          color: { type: 'string' },
        },
        required: ['color'],
        type: 'object',
      },
    };
  }
  return {};
});

// Mock the dynamic import
vi.mock('/mocked/path', () => ({
  default: mockCustomFieldsParser,
}));

// Mock the import function
vi.mock('node:module', () => ({
  import: vi.fn().mockResolvedValue({
    default: mockCustomFieldsParser,
  }),
}));

// Set up the virtual file system with our custom fields parser
vol.fromJSON({
  '/path/to/custom/parser.ts': `
export default (key: string, field: any) => {
  switch (field.field_type) {
    case 'native-color-picker':
      return {
        [key]: {
          properties: {
            color: { type: 'string' },
          },
          required: ['color'],
          type: 'object',
        },
      };
    default:
      return {};
  }
};
`,
  // Add a mock storyblok.ts file for testing generateStoryblokTypes
  '/mocked/path': `
// Storyblok types
export type StoryblokPropertyType = 'text' | 'textarea' | 'number' | 'boolean' | 'multilink' | 'bloks' | 'custom';

export interface StoryblokText {
  type: 'text';
  required?: boolean;
}

export interface StoryblokTextarea {
  type: 'textarea';
  required?: boolean;
}

export interface StoryblokNumber {
  type: 'number';
  required?: boolean;
}

export interface StoryblokBoolean {
  type: 'boolean';
  required?: boolean;
}

export interface StoryblokMultilink {
  type: 'multilink';
  required?: boolean;
  email_link_type?: boolean;
  asset_link_type?: boolean;
}

export interface StoryblokBloks {
  type: 'bloks';
  required?: boolean;
  restrict_components?: boolean;
  component_whitelist?: string[];
  component_group_whitelist?: string[];
  restrict_type?: 'groups' | 'components';
}

export interface StoryblokCustom {
  type: 'custom';
  required?: boolean;
  field_type?: string;
}
`,
});

// Set up the mock content for readFileSync
const mockStoryblokContent = vol.readFileSync('/mocked/path', 'utf-8') as string;
vi.mocked(readFileSync).mockImplementation((path) => {
  if (path === '/mocked/path') {
    return mockStoryblokContent;
  }
  return '';
});

const mockSpaceData: SpaceData = {
  components: [
    {
      name: 'test_component',
      display_name: 'Test Component',
      created_at: '2023-01-01T00:00:00Z',
      updated_at: '2023-01-01T00:00:00Z',
      id: 1,
      schema: {
        title: {
          type: 'text',
          required: true,
        },
        description: {
          type: 'textarea',
          required: false,
        },
      },
      color: null,
      internal_tags_list: [],
      internal_tag_ids: [],
    },
  ],
  groups: [],
  presets: [],
  internalTags: [],
};

describe('generate types actions', () => {
  it('should generate types successfully', async () => {
    // Create mock options
    const mockOptions: GenerateTypesOptions = {
      strict: false,
    };

    // Call the function with the correct parameters
    const result = await generateTypes(mockSpaceData, mockOptions);

    // Verify the result contains expected content
    expect(result).toContain('// This file was generated by the storyblok CLI.');
    expect(result).toContain('// DO NOT MODIFY THIS FILE BY HAND.');
    expect(result).toContain('export interface TestComponent');
    expect(result).toContain('title: string');
    expect(result).toContain('description?: string');
    expect(result).toContain('component: "test_component"');
    expect(result).toContain('_uid: string');
    expect(result).toContain('[k: string]: unknown');
  });

  it('should generate types successfully with strict mode', async () => {
    const mockOptions: GenerateTypesOptions = {
      strict: true,
    };

    const result = await generateTypes(mockSpaceData, mockOptions);

    expect(result).not.toContain('[k: string]: unknown');
  });

  it('should handle customFieldsParser option', async () => {
    // Create mock options with customFieldsParser
    const mockOptions: GenerateTypesOptions = {
      strict: false,
      customFieldsParser: '/path/to/custom/parser.ts',
    };

    // Call the function with the customFieldsParser option
    const result = await generateTypes(mockSpaceData, mockOptions);

    // Verify that the result is generated successfully
    expect(result).toBeDefined();
    if (result) {
      expect(typeof result).toBe('string');
      expect(result.length).toBeGreaterThan(0);
    }

    // Verify that resolve was called with the customFieldsParser path
    expect(resolve).toHaveBeenCalledWith('/path/to/custom/parser.ts');
  });

  it('should handle compilerOptions option', async () => {
    // Create mock options with compilerOptions
    const mockOptions: GenerateTypesOptions = {
      strict: false,
      compilerOptions: '/path/to/compiler/options',
    };

    // Call the function with the compilerOptions option
    const result = await generateTypes(mockSpaceData, mockOptions);

    // Verify that the result is generated successfully
    expect(result).toBeDefined();
    if (result) {
      expect(typeof result).toBe('string');
      expect(result.length).toBeGreaterThan(0);
    }

    // Verify that resolve was called with the compilerOptions path
    expect(resolve).toHaveBeenCalledWith('/path/to/compiler/options');
  });

  it('should apply typePrefix to component type names', async () => {
    // Create mock options with typePrefix
    const mockOptions: GenerateTypesOptions = {
      strict: false,
      typePrefix: 'Custom',
    };

    // Call the function with the typePrefix option
    const result = await generateTypes(mockSpaceData, mockOptions);

    // Verify that the result contains the expected prefixed type name
    expect(result).toContain('export interface CustomTestComponent');
    expect(result).toContain('title: string');
    expect(result).toContain('description?: string');
    expect(result).toContain('component: "test_component"');
    expect(result).toContain('_uid: string');
    expect(result).toContain('[k: string]: unknown');
  });
});

describe('getComponentType', () => {
  it('should convert component name to PascalCase', () => {
    const options: GenerateTypesOptions = {};
    expect(getComponentType('test_component', options)).toBe('TestComponent');
  });

  it('should handle special characters in component name', () => {
    const options: GenerateTypesOptions = {};
    expect(getComponentType('test-component!', options)).toBe('TestComponent');
  });

  it('should handle emojis in component name', () => {
    const options: GenerateTypesOptions = {};
    expect(getComponentType('testðŸ˜€component', options)).toBe('TestComponent');
  });

  it('should handle multiple consecutive special characters', () => {
    const options: GenerateTypesOptions = {};
    expect(getComponentType('test___component', options)).toBe('TestComponent');
  });

  it('should handle component names starting with numbers', () => {
    const options: GenerateTypesOptions = {};
    expect(getComponentType('123component', options)).toBe('_123component');
  });

  it('should apply typePrefix when provided', () => {
    const options: GenerateTypesOptions = {
      typePrefix: 'Custom',
    };
    expect(getComponentType('test_component', options)).toBe('CustomTestComponent');
  });

  it('should handle empty typePrefix', () => {
    const options: GenerateTypesOptions = {
      typePrefix: '',
    };
    expect(getComponentType('test_component', options)).toBe('TestComponent');
  });

  it('should handle component names with spaces', () => {
    const options: GenerateTypesOptions = {};
    expect(getComponentType('test component', options)).toBe('TestComponent');
  });
});

describe('component property type annotations', () => {
  it('should handle text property type', async () => {
    // Create a component with text property type
    const componentWithTextType: SpaceComponent = {
      name: 'test_component',
      display_name: 'Test Component',
      created_at: '2023-01-01T00:00:00Z',
      updated_at: '2023-01-01T00:00:00Z',
      id: 1,
      schema: {
        title: {
          type: 'text',
          required: true,
        },
      },
      color: null,
      internal_tags_list: [],
      internal_tag_ids: [],
    };

    // Create a space data with this component
    const spaceData: SpaceData = {
      components: [componentWithTextType],
      groups: [],
      presets: [],
      internalTags: [],
    };

    // Generate types
    const result = await generateTypes(spaceData, { strict: false });

    // Verify that the result contains the expected property type
    expect(result).toContain('title: string');
  });

  it('should handle textarea property type', async () => {
    // Create a component with textarea property type
    const componentWithTextareaType: SpaceComponent = {
      name: 'test_component',
      display_name: 'Test Component',
      created_at: '2023-01-01T00:00:00Z',
      updated_at: '2023-01-01T00:00:00Z',
      id: 1,
      schema: {
        description: {
          type: 'textarea',
          required: false,
        },
      },
      color: null,
      internal_tags_list: [],
      internal_tag_ids: [],
    };

    // Create a space data with this component
    const spaceData: SpaceData = {
      components: [componentWithTextareaType],
      groups: [],
      presets: [],
      internalTags: [],
    };

    // Generate types
    const result = await generateTypes(spaceData, { strict: false });

    // Verify that the result contains the expected property type
    expect(result).toContain('description?: string');
  });

  it('should handle number property type', async () => {
    // Create a component with number property type
    const componentWithNumberType: SpaceComponent = {
      name: 'test_component',
      display_name: 'Test Component',
      created_at: '2023-01-01T00:00:00Z',
      updated_at: '2023-01-01T00:00:00Z',
      id: 1,
      schema: {
        count: {
          type: 'number',
          required: false,
        },
      },
      color: null,
      internal_tags_list: [],
      internal_tag_ids: [],
    };

    // Create a space data with this component
    const spaceData: SpaceData = {
      components: [componentWithNumberType],
      groups: [],
      presets: [],
      internalTags: [],
    };

    // Generate types
    const result = await generateTypes(spaceData, { strict: false });

    // Verify that the result contains the expected property type
    expect(result).toContain('count?: string');
  });

  it('should handle boolean property type', async () => {
    // Create a component with boolean property type
    const componentWithBooleanType: SpaceComponent = {
      name: 'test_component',
      display_name: 'Test Component',
      created_at: '2023-01-01T00:00:00Z',
      updated_at: '2023-01-01T00:00:00Z',
      id: 1,
      schema: {
        isActive: {
          type: 'boolean',
          required: false,
        },
      },
      color: null,
      internal_tags_list: [],
      internal_tag_ids: [],
    };

    // Create a space data with this component
    const spaceData: SpaceData = {
      components: [componentWithBooleanType],
      groups: [],
      presets: [],
      internalTags: [],
    };

    // Generate types
    const result = await generateTypes(spaceData, { strict: false });

    // Verify that the result contains the expected property type
    expect(result).toContain('isActive?: boolean');
  });

  it('should handle multilink property type', async () => {
    // Create a component with multilink property type
    const componentWithMultilinkType: SpaceComponent = {
      name: 'test_component',
      display_name: 'Test Component',
      created_at: '2023-01-01T00:00:00Z',
      updated_at: '2023-01-01T00:00:00Z',
      id: 1,
      schema: {
        link: {
          type: 'multilink',
          required: false,
          email_link_type: false,
          asset_link_type: true,
        },
      },
      color: null,
      internal_tags_list: [],
      internal_tag_ids: [],
    };

    // Create a space data with this component
    const spaceData: SpaceData = {
      components: [componentWithMultilinkType],
      groups: [],
      presets: [],
      internalTags: [],
    };

    // Generate types
    const result = await generateTypes(spaceData, { strict: false });

    // Verify that the result contains the expected property type
    expect(result).toContain('link?:');
  });

  it('should handle bloks property type with component restrictions', async () => {
    // Create a component with bloks property type and component restrictions
    const componentWithBloksType: SpaceComponent = {
      name: 'test_component',
      display_name: 'Test Component',
      created_at: '2023-01-01T00:00:00Z',
      updated_at: '2023-01-01T00:00:00Z',
      id: 1,
      schema: {
        content: {
          type: 'bloks',
          required: false,
          restrict_components: true,
          component_whitelist: ['button', 'image'],
        },
      },
      color: null,
      internal_tags_list: [],
      internal_tag_ids: [],
    };

    // Create a space data with this component
    const spaceData: SpaceData = {
      components: [componentWithBloksType],
      groups: [],
      presets: [],
      internalTags: [],
    };

    // Generate types
    const result = await generateTypes(spaceData, { strict: false });

    // Verify that the result contains the expected property type
    expect(result).toContain('content?:');
  });

  it('should handle tabbed properties correctly', async () => {
    // Create a component with tabbed properties
    const componentWithTabbedProperties: SpaceComponent = {
      name: 'test_component',
      display_name: 'Test Component',
      created_at: '2023-01-01T00:00:00Z',
      updated_at: '2023-01-01T00:00:00Z',
      id: 1,
      schema: {
        'tab-content': {
          type: 'tab',
          display_name: 'Content',
        },
        'title': {
          type: 'text',
          required: true,
        },
      },
      color: null,
      internal_tags_list: [],
      internal_tag_ids: [],
    };

    // Create a space data with this component
    const spaceData: SpaceData = {
      components: [componentWithTabbedProperties],
      groups: [],
      presets: [],
      internalTags: [],
    };

    // Generate types
    const result = await generateTypes(spaceData, { strict: false });

    // Verify that the result contains the expected property type but not the tab
    expect(result).toContain('title: string');
    expect(result).not.toContain('tab-content');
  });

  it('should handle custom property type with customFieldsParser', async () => {
    // Create a component with custom property type
    const componentWithCustomType: SpaceComponent = {
      name: 'test_component',
      display_name: 'Test Component',
      created_at: '2023-01-01T00:00:00Z',
      updated_at: '2023-01-01T00:00:00Z',
      id: 1,
      schema: {
        colorPicker: {
          type: 'custom',
          field_type: 'native-color-picker',
          required: false,
        },
      },
      color: null,
      internal_tags_list: [],
      internal_tag_ids: [],
    };

    // Create a space data with this component
    const spaceData: SpaceData = {
      components: [componentWithCustomType],
      groups: [],
      presets: [],
      internalTags: [],
    };

    // Create mock options with customFieldsParser
    const mockOptions: GenerateTypesOptions = {
      strict: false,
      customFieldsParser: '/path/to/custom/parser.ts',
    };

    // Reset the mock to ensure it's called with the right parameters
    mockCustomFieldsParser.mockClear();

    // Generate types
    const result = await generateTypes(spaceData, mockOptions);

    // Verify that the custom fields parser was called
    expect(mockCustomFieldsParser).toHaveBeenCalled();

    // Verify that the result contains the expected property type
    expect(result).toContain('colorPicker?:');
    expect(result).toContain('color: string');
  });
});

describe('generateStoryblokTypes', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should generate Storyblok types successfully with default options', async () => {
    // Call the function with default options
    const result = await generateStoryblokTypes();

    // Verify that the function returns true
    expect(result).toBe(true);

    // Verify that readFileSync was called with the correct path
    expect(readFileSync).toHaveBeenCalledWith('/mocked/path', 'utf-8');

    // Verify that saveToFile was called with the correct parameters
    expect(saveToFile).toHaveBeenCalledWith('/mocked/joined/path', expect.stringContaining('// This file was generated by the storyblok CLI.'));
    expect(saveToFile).toHaveBeenCalledWith('/mocked/joined/path', expect.stringContaining('export type StoryblokPropertyType'));
    expect(saveToFile).toHaveBeenCalledWith('/mocked/joined/path', expect.stringContaining('export interface StoryblokText'));
  });

  it('should generate Storyblok types with custom filename', async () => {
    // Call the function with custom filename
    const result = await generateStoryblokTypes({ filename: 'custom-storyblok' });

    // Verify that the function returns true
    expect(result).toBe(true);

    // Verify that saveToFile was called with the correct filename
    expect(saveToFile).toHaveBeenCalledWith('/mocked/joined/path', expect.any(String));
    expect(join).toHaveBeenCalledWith(expect.any(String), 'custom-storyblok.d.ts');
  });

  it('should generate Storyblok types with custom path', async () => {
    // Call the function with custom path
    const result = await generateStoryblokTypes({ path: '/custom/path' });

    // Verify that the function returns true
    expect(result).toBe(true);

    // Verify that resolve was called with the correct path
    expect(resolve).toHaveBeenCalledWith(expect.any(String), '/custom/path', 'types');
  });

  it('should extract all Storyblok type definitions', async () => {
    // Call the function
    await generateStoryblokTypes();

    // Get the content passed to saveToFile
    const savedContent = vi.mocked(saveToFile).mock.calls[0][1];

    // Verify that all expected type definitions are included
    expect(savedContent).toContain('export type StoryblokPropertyType');
    expect(savedContent).toContain('export interface StoryblokText');
    expect(savedContent).toContain('export interface StoryblokTextarea');
    expect(savedContent).toContain('export interface StoryblokNumber');
    expect(savedContent).toContain('export interface StoryblokBoolean');
    expect(savedContent).toContain('export interface StoryblokMultilink');
    expect(savedContent).toContain('export interface StoryblokBloks');
    expect(savedContent).toContain('export interface StoryblokCustom');
  });
});
